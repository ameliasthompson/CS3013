// Maximilian Thompson

#include "option.h"

int selectOption(int size) {
	// Read from stdin.
	char choiceStr[MAX_IN_LENGTH];
	fgets(choiceStr, MAX_IN_LENGTH, stdin);

	// Check for end of file.
	if (feof(stdin)) {
		return OPT_E;
	}
	
	// Identify if the input is one of the preset letter options.
	switch(choiceStr[0]) {
	case 'a':
		return OPT_A;
	case 'c':
		return OPT_C;
	case 'e':
		return OPT_E;
	case 'p':
		return OPT_P;
	}

	// Identify if the input at least starts with a number.
	if (isdigit(choiceStr[0])) {
		// We now know that if atoi returns 0, it's actually a 0 and not an error.
		int option = atoi(choiceStr);
		
		// Identify if it's in range.
		if (option >= 0 && option <= size) {
			// We now know the option is 100% valid.
			return option;
		}
	}
	
	// Otherwise the option is junk, so we error.
	return -1;
}

int addOption(struct option** cmds, int* size) {
	// Read user input. (Leave room for autogenerated header flair.)
	char nameStr[MAX_IN_LENGTH-6], headStr[MAX_IN_LENGTH], pathStr[MAX_IN_LENGTH];
	char* defArgs[MAX_DEF_ARGS];
	int blocking = 1; // Stuff is blocking by default.
	printf("Command?: ");
	fgets(nameStr, MAX_IN_LENGTH, stdin);

	// Clean up the string.
	cleanNewline(nameStr);

	// Break the string up into arguments.
	char buf[MAX_IN_LENGTH];
	strcpy (buf, nameStr);
	// Check to see if anything was actually inputted.
	if (buf[0] != '\0') {
		char* tmp; // Buffer for the buffer.

		// Get path.
		tmp = strtok(buf, " ");
		strcpy (pathStr, tmp);

		// Get arguments if there are any.
		tmp = strtok(NULL, " "); // Prime strtok().
		int argsSize = 0;
		while (argsSize < MAX_DEF_ARGS - 1 && tmp != NULL) {
			if (strcmp(tmp, "&")) {
				// Argument is a don't block please one.
				blocking = 0;

			} else {
				// tmp actually has an argument if you're here.
				defArgs[argsSize] = malloc(MAX_IN_LENGTH * sizeof(char));
				strcpy(defArgs[argsSize], tmp); // Write argument to array.
			
				tmp = strtok(NULL, " "); // Should keep going on buf.
				argsSize++;
			}
		}

		defArgs[argsSize] = NULL; // Terminator.

	} else {
		// The user didn't actually input anything.
		return -1;
	}

	// Generate header.
	headStr[0] = '\0'; // Init string to be blank.
	strcat(headStr, "-- ");
	strcat(headStr, nameStr);
	strcat(headStr, " --");

	// Append the option, and return what it does.
	return appendOption(cmds, size, pathStr, nameStr, "A user generated command.", headStr, defArgs, 0, 0, blocking);
}

int addOptionVerbose(struct option** cmds, int* size) {
	// Read user selections. (Leave room for autogen header padding in name.)
	char pathStr[MAX_IN_LENGTH], descStr[MAX_IN_LENGTH], nameStr[MAX_IN_LENGTH-6], headStr[MAX_IN_LENGTH];
	printf("Path to command?: ");
	fgets(pathStr, MAX_IN_LENGTH, stdin);
	printf("Name of command?: ");
	fgets(nameStr, MAX_IN_LENGTH-6, stdin);
	printf("Description?: ");
	fgets(descStr, MAX_IN_LENGTH, stdin);
	
	// AT THE MOMENT, IT IS ASSUMED THE USER ALWAYS WANTS ARGS.
	// AT THE MOMENT, IT IS ASSUMED THE USER ALWAYS WANTS A PATH ARGUMENT.
	// AT THE MOMENT, IT IS ASSUMED THE USER WANTS NO DEFAULT ARGUMENTS.
	// AT THE MOMENT, IT IS ASSUMED THE USER ALWAYS WANTS BLOCKING.
	
	// Clean up the strings.
	cleanNewline(pathStr);
	cleanNewline(nameStr);
	cleanNewline(descStr);
	
	// Generate header.
	headStr[0] = '\0'; // Init string to be blank.
	strcat(headStr, "-- ");
	strcat(headStr, nameStr);
	strcat(headStr, " --");
	
	// Append the option, and return what it does.
	return appendOption(cmds, size, pathStr, nameStr, descStr, headStr, NULL,  1, 1, 1);
}

int appendOption(struct option** cmds, int* size, const char* path, const char* name, const char* desc, const char* head, char** defArgs, int args, int argPath, int blocking) {
	// Allocate new struct.
	struct option* opt = malloc(sizeof(struct option));
	if (opt == NULL) return -1; // Error if allocation failed.
	
	// Populate struct with arguments.
	strcpy(opt->path, path);
	strcpy(opt->name, name);
	strcpy(opt->desc, desc);
	strcpy(opt->head, head);
	opt->defArgs = defArgs;
	opt->args = args;
	opt->argPath = argPath;
	opt->blocking = blocking;

	// Push it to the array.
	cmds[*size] = opt;
	(*size)++;
	
	
	return *size - 1; // Return the id of the new command.
}